![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/6a4bfc9f-642e-463b-830b-4de623986f4d)






![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/0ffc237e-9965-4f6c-8546-4d1621c09514)

# Diffie-Hellman Starter 1

### Description :
```
The set of integers modulo n, together with the operations of both addition and multiplication is a ring. This means that adding or multiplying any two elements in the set returns another element in the set.

When the modulus is prime: n = p, we are guaranteed an inverse of every element in the set, and so the ring is promoted to a field. We refer to this field as a finite field Fp.

The Diffie-Hellman protocol works with elements of some finite field Fp, where the prime modulus is typically a large prime.

Given the prime p = 991, and the element g = 209, find the inverse element d such that g * d mod 991 = 1.
```

### Solution :
```python
from Crypto.Util.number import *

g = 209
p = 991
print(inverse(g,p))
```
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/f5261bba-12f8-4fc4-886d-6dad8f58734a)

<br><br><br>
***
<br><br><br>

# Diffie-Hellman Starter 2

### Description :
```
Every element of a finite field Fp can be used to make a subgroup H under repeated action of multiplication. In other words, for an element g: H = {g, g^2, g^3, ...}

A primitive element of Fp is an element whose subgroup H = Fp, i.e., every element of Fp, can be written as g^n mod p for some integer n. Because of this, primitive elements are sometimes called generators of the finite field.

For the finite field with p = 28151 find the smallest element g which is a primitive element of Fp.
```

### Solution :
```python
from Crypto.Util.number import *

p = 28151
Fp = set(range(1, p)) 

for g in range(1, p):
    print('g:', g)
    H = set() 
    for n in range(p):
        H.add(pow(g, n, p))  # every element of Fp can be written as g^n mod p
    
    if Fp == H:     # if Fp = H, that g's the primitive element
        print('found!', g)
        break
```

<br><br><br>
***
<br><br><br>

# Diffie-Hellman Starter 3

### Description :
```
The Diffie-Hellman protocol is used because the discrete logarithm is assumed to be a "hard" computation for carefully chosen groups.

The first step of the protocol is to establish a prime p and some generator of the finite field g. These must be carefully chosen to avoid special cases where the discrete log can be solved with efficient algorithms. For example, a safe prime p = 2*q +1 is usually picked such that the only factors of p - 1 are {2,q} where q is some other large prime. This protects DH from the Pohligâ€“Hellman algorithm.

The user then picks a secret integer a < p and calculates g^a mod p. This can be transmitted over an insecure network and due to the assumed difficulty of the discrete logarithm, the secret integer should be infeasible to compute.

Given the NIST parameters:

g: 2

p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

Calculate the value of g^a mod p for

a: 972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815
```
### Solution :
```python
g = 2
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
a = 972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815
print(pow(g,a,p))
```
```
1806857697840726523322586721820911358489420128129248078673933653533930681676181753849411715714173604352323556558783759252661061186320274214883104886050164368129191719707402291577330485499513522368289395359523901406138025022522412429238971591272160519144672389532393673832265070057319485399793101182682177465364396277424717543434017666343807276970864475830391776403957550678362368319776566025118492062196941451265638054400177248572271342548616103967411990437357924
```

<br><br><br>
***
<br><br><br>

# Diffie-Hellman Starter 4

### Description :
```
Now it's time to calculate a shared secret using data received from your friend Alice. Like before, we will be using the NIST parameters:

g: 2

p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

You have received the following integer from Alice:

A: 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601

You generate your secret integer b and calculate your public one B, which you send to Alice.

b: 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720

B: 518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172

You and Alice are now able to calculate a shared secret, which would be infeasible to calculate knowing only {g,p,A,B}.

What is your shared secret?
```

### Solution :
So we know that in dh, there's g,p which is public \
and each person communicatin has their own secret keys a, b \
they send to each other `A = g^a mod p` and `B = g^b mod p` \
the one who gets `A` computes `A**b mod p` and the one with `B` computes `B**a mod p` \
ultimately they both end up having the same value `g**ab mod p`

so we got `A` `g` `p` `b` `B` and we gotta find the final shared secret \
easy enough, we got `A`, shared secret would be `A**b mod p` i.e. `(g^a mod p)^b mod p` = `g**ab mod p` \
```python
A = 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
g = 2
b = 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720
print(pow(A,b,p))
```
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/a619281a-f62e-4ede-a5e6-14a01f71416e)


<br><br><br>
***
<br><br><br>

# Diffie-Hellman Starter 5

### Description :
```
Alice wants to send you her secret flag and asks you to generate a shared secret with her. She also tells you she will be using the NIST standard:

g: 2

p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

You receive the following integer from Alice:

A: 112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784

You then generate your secret integer and calculate your public one, which you send to Alice.

b: 197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944

B: 1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581

Individually you each use the shared secret to derive an AES private key. This allows you to encrypt large amounts of data over your channel without needing to exchange keys again.

Alice sends you the following IV and ciphertext:

{'iv': '737561146ff8194f45290f5766ed6aba', 'encrypted_flag': '39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c'}

Decrypt this to obtain your flag!
```

### Solution :

So like in starter 4, we can derive `g^ab mod p` i.e. the final shared secret \
now we also got an iv, and ciphertext, the shared secret gonna be the key \
use that, aes decrypt and we got flag.
```python
from Crypto.Cipher import AES 
from Crypto.Util.number import *
from Crypto.Util.Padding import pad, unpad
import hashlib

p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
b = 197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944
A = 112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784

iv = long_to_bytes(0x737561146ff8194f45290f5766ed6aba)
ct = long_to_bytes(0x39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c)

K = pow(A,b,p)
# print(K)

sha1 = hashlib.sha1()
sha1.update(str(K).encode('ascii'))
key = sha1.digest()[:16]

cipher = AES.new(key ,AES.MODE_CBC, iv)
flag = cipher.decrypt(ct)
print(unpad(flag,16))
```

<br><br><br>
***
<br><br><br>

# Parameter Injection

### Description :
```
You're in a position to not only intercept Alice and Bob's DH key exchange, but also rewrite their messages. Think about how you can play with the DH equation that they calculate, and therefore sidestep the need to crack any discrete logarithm problem.

Use the script from "Diffie-Hellman Starter 5" to decrypt the flag once you've recovered the shared secret.

Connect at socket.cryptohack.org 13371
```

### Solution :
again, we got p,g,A,B but we need key to crack the aes. \
from the description, chall name and the fact that we could manipulate what alice and bob were recieving, I felt it was hinting that we \
gotta somehow manipulate their inputs to get key \
so `A = g**a mod p` \
`B = g**b mod p` \
`K = A**b = B**a = g**(ab) mod p` \
The encryption with aes is being done after alice recieves bob's `B` \
So i figured if we play with bob's `B` we can crack the shared key \
I then sent `B = 0` to Alice \
so alice would now compute `K = B**a` => `K = 0**a` \
=> `K = 0`

we now know K \
we now get flag \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/4f00d058-4b4d-4c4f-ae53-12563f29c578)

```python
from Crypto.Util.number import *
from Crypto.Cipher import AES 
import hashlib
from Crypto.Util.Padding import pad,unpad


K = 0
iv = long_to_bytes(0x2778c63cabb9b4f59c0c58c3b06c59a6)
ct = long_to_bytes(0x5602771ecc05d83145b0eb640b1ecf37a1a0b953fee8468fbc9cb1c231d9f06c)

sha1 = hashlib.sha1()
sha1.update(str(K).encode('ascii'))
key = sha1.digest()[:16]

cipher = AES.new(key ,AES.MODE_CBC, iv)
flag = cipher.decrypt(ct)
print(flag)
```
Yessir \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/1ad3aeda-e186-4551-a6ee-e0a6b58b32a3)


<br><br><br>
***
<br><br><br>

# Export Grade

### Description :
```
Alice and Bob are using legacy codebases and need to negotiate parameters they both support. You've man-in-the-middled this negotiation step, and can passively observe thereafter. How are you going to ruin their day this time?

Connect at socket.cryptohack.org 13379
```

### Solution :
after running the nc once, I understood we could only manipulate the bit size of p in this chall \
naturally I chose the smallest one, because that would be the one most insecure or factorable \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/02639f76-a577-4963-9781-324029070471)

I figured i was supposed to find the shared secret somehow, find `a` or `b`. \
I googled around for a while, and saw the `discrete log problem` popping around a lot 

basically if you have `g**a mod p = A` if you know g,p,A, u get the problem of tryna find `a` \
finding a is harder if p is larger, because then the field to find it through enlarges. \
There were a bunch of algorithms on solving discrete log problem \
the `Baby Step Giant Step` , `Pollih-Hellman` etc. \
https://risencrypto.github.io/PohligHellman/


I tried to apply these but everything flew right across the brain \
A while later I found sage has a built in discrete_log function that literally finds a for `g**a mod p = A` in one line\
https://cryptohack.gitbook.io/cryptobook/abstract-algebra/groups/untitled \
I just applied that and yes \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/a4b785dd-57a1-4a99-b01b-b850c291e011)

```python
from Crypto.Util.number import *
from Crypto.Cipher import AES 
import hashlib
from Crypto.Util.Padding import pad,unpad

a = 2561142517778670228
p = 0xde26ab651b92a129
B = 0xb5ea2a8da43a85ec

K = pow(B,a,p)

iv = long_to_bytes(0x7e58ddf42e04271532c11f8d570f8378)
ct = long_to_bytes(0xf8e4ab49968dac617b6062f5eb8609f43476a39d9d5448a0bd6967ee4278ad2c)

sha1 = hashlib.sha1()
sha1.update(str(K).encode('ascii'))
key = sha1.digest()[:16]

cipher = AES.new(key ,AES.MODE_CBC, iv)
flag = cipher.decrypt(ct)
print(flag)
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/fbc765b0-66c1-4b11-b2b4-1b5590680a25)



<br><br><br>
***
<br><br><br>

# Script Kiddie

### Description :
```
Found this cool script on Github and I've been using it to keep my secrets from anyone listening in on the school wifi!
```
```python
from Crypto.Cipher import AES
import hashlib
import secrets


def header():
    print("""  _____  _  __  __ _
 |  __ \(_)/ _|/ _(_)
 | |  | |_| |_| |_ _  ___
 | |  | | |  _|  _| |/ _ \
 | |__| | | | | | | |  __/
 |_____/|_|_| |_| |_|\___|
 | |  | |    | | |
 | |__| | ___| | |_ __ ___   __ _ _ __
 |  __  |/ _ \ | | '_ ` _ \ / _` | '_ \
 | |  | |  __/ | | | | | | | (_| | | | |
 |_|  |_|\___|_|_|_| |_| |_|\__,_|_| |_|

                                        """)


def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))


def pkcs7_unpad(message, block_size=16):
    if len(message) == 0:
        raise Exception("The input data must contain at least one byte")
    if not is_pkcs7_padded(message):
        return message
    padding_len = message[-1]
    return message[:-padding_len]


def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return pkcs7_unpad(plaintext).decode('ascii')


def generate_public_int(g, a, p):
    return g ^ a % p


def generate_shared_secret(A, b, p):
    return A ^ b % p


def goodbye():
    print('Goodbye!')


def main():
    header()
    print('[-] Collecting data from Alice')
    p = int(input('> p: '))
    q = (p - 1) // 2
    g = int(input('> g: '))
    A = int(input('> A: '))
    print('[+] All data collected from Alice')

    print('[+] Generating public integer for alice')
    b = secrets.randbelow(q)
    B = generate_public_int(g, b, p)
    print(f'[+] Please send the public integer to Alice: {B}')
    print('')
    input('[+] Press any key to continue')
    print('')

    print('[+] Generating shared secret')
    shared_secret = generate_shared_secret(A, b, p)

    query = input('Would you like to decrypt a message? (y/n)\n')
    if query == 'y':
        iv = input('[-] Please enter iv (hex string)\n')
        ciphertext = input('[-] Please enter ciphertext (hex string)\n')
        flag = decrypt_flag(shared_secret, iv, ciphertext)
        print(f'[+] Flag recovered: {flag}')
        goodbye()
    else:
        goodbye()


if __name__ == '__main__':
    main()
```
```
p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
g: 2
A: 539556019868756019035615487062583764545019803793635712947528463889304486869497162061335997527971977050049337464152478479265992127749780103259420400564906895897077512359628760656227084039215210033374611483959802841868892445902197049235745933150328311259162433075155095844532813412268773066318780724878693701177217733659861396010057464019948199892231790191103752209797118863201066964703008895947360077614198735382678809731252084194135812256359294228383696551949882
B: 652888676809466256406904653886313023288609075262748718135045355786028783611182379919130347165201199876762400523413029908630805888567578414109983228590188758171259420566830374793540891937904402387134765200478072915215871011267065310188328883039327167068295517693269989835771255162641401501080811953709743259493453369152994501213224841052509818015422338794357540968552645357127943400146625902468838113443484208599332251406190345653880206706388377388164982846343351
iv: 'c044059ae57b61821a9090fbdefc63c5'
encrypted_flag: 'f60522a95bde87a9ff00dc2c3d99177019f625f3364188c1058183004506bf96541cf241dad1c0e92535564e537322d7'
```

### Solution :

Will not lie, initially was bruteforcing `b` to be a random number below p \
Apologies, i experienced brainfog. \ 
Then I saw this in the script : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/e81b4057-f763-4a29-b19a-d085e54df239)

That is not dh. My guy is xor'ing. \
This makes it a whole lot easier. \
we have `B` which is `g ^ b % p` = `g ^ b` \
so we can just do `B ^ g` and that gives us b \
calculate the shared secret `A ^ b % p` and done 
```python
from Crypto.Util.number import *
from Crypto.Cipher import AES 
from Crypto.Util.Padding import pad, unpad
import hashlib 

p= 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
g= 2
A= 539556019868756019035615487062583764545019803793635712947528463889304486869497162061335997527971977050049337464152478479265992127749780103259420400564906895897077512359628760656227084039215210033374611483959802841868892445902197049235745933150328311259162433075155095844532813412268773066318780724878693701177217733659861396010057464019948199892231790191103752209797118863201066964703008895947360077614198735382678809731252084194135812256359294228383696551949882
B= 652888676809466256406904653886313023288609075262748718135045355786028783611182379919130347165201199876762400523413029908630805888567578414109983228590188758171259420566830374793540891937904402387134765200478072915215871011267065310188328883039327167068295517693269989835771255162641401501080811953709743259493453369152994501213224841052509818015422338794357540968552645357127943400146625902468838113443484208599332251406190345653880206706388377388164982846343351
iv= bytes.fromhex('c044059ae57b61821a9090fbdefc63c5')
ct= bytes.fromhex('f60522a95bde87a9ff00dc2c3d99177019f625f3364188c1058183004506bf96541cf241dad1c0e92535564e537322d7')

# B = g ^ (b % p)
# B ^ g = (b % p)
# B ^ g = b

b = B ^ g

# K = pow(A,b,p)
# but in this case K = A ^ b mod p
K = A ^ b % p

sha1 = hashlib.sha1()
sha1.update(str(K).encode('ascii'))
key = sha1.digest()[:16]
cipher = AES.new(key ,AES.MODE_CBC, iv)
flag = cipher.decrypt(ct)
print(unpad(flag,16))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/5e94870a-04e7-409f-9092-962417ba0107)
