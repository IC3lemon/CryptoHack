![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/28022cb9-a035-4a54-b79b-484cee8681af)






# Factoring

### Description : 
```
So far we've been using the product of small primes for the modulus, but small primes aren't much good for RSA as they can be factorised using modern methods.

What is a "small prime"? There was an RSA Factoring Challenge with cash prizes given to teams who could factorise RSA moduli. This gave insight to the public into how long various key sizes would remain safe. Computers get faster, algorithms get better, so in cryptography it's always prudent to err on the side of caution.

These days, using primes that are at least 1024 bits long is recommendedâ€”multiplying two such 1024 primes gives you a modulus that is 2048 bits large. RSA with a 2048-bit modulus is called RSA-2048.

Some say that to really remain future-proof you should use RSA-4096 or even RSA-8192. However, there is a tradeoff here; it takes longer to generate large prime numbers, plus modular exponentiations are predictably slower with a large modulus.

Factorise the 150-bit number 510143758735509025530880200653196460532653147 into its two constituent primes. Give the smaller one as your answer.
```

### Solution :

```python
from sympy import *

N = 510143758735509025530880200653196460532653147
primes = list(factorint(N).keys())

print("i think :", min(primes))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/212e4051-97a8-4bb2-8df4-7b7e7ea25c47)
<br><br><br>
***
<br><br><br>

# Inferius Prime

### Description :
```
Here is my super-strong RSA implementation, because it's 1600 bits strong it should be unbreakable... at least I think so!
```

```python
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD

e = 3

# n will be 8 * (100 + 100) = 1600 bits strong which is pretty good
while True:
    p = getPrime(100)
    q = getPrime(100)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    if d != -1 and GCD(e, phi) == 1:
        break

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag
```
```
n = 742449129124467073921545687640895127535705902454369756401331
e = 3
ct = 39207274348578481322317340648475596807303160111338236677373
```

### Solution :

my boi factorint failed me here, so I turned to another boi factordb

```python
from Crypto.Util.number import *
from factordb.factordb import FactorDB

n = 742449129124467073921545687640895127535705902454369756401331
e = 3
ct = 39207274348578481322317340648475596807303160111338236677373

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

p = primes[0]
q = primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)

pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/2c6fe08a-fa8d-41b5-a294-2999711deda1)

<br><br><br>
***
<br><br><br>

# Monoprime

### Description :
```
Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?
```
```
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942
```

### Sollution :

got two approaches for this...
1. Something I learnt from cryptohack...
   p = n, q = 1 (duh)
   so phi = p-1 (phi cannot be zero, that won't make sense. So no multiplying q-1)
   we got phi, e, get d = e^-1 % phi, and solved with pow(ct,d,n)
```
from Crypto.Util.number import *

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

phi = n-1
d = inverse(e,phi)

pt = pow(ct,d,n)
print(long_to_bytes(pt))
```


2. Something I learnt in boilerctf... roots of unity
```
from Crypto.Util.number import *

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

def roots_of_unity(e, phi, n, rounds=500):
    phi_coprime = phi
    while GCD(phi_coprime, e) != 1:
        phi_coprime //=  GCD(phi_coprime, e)

    roots = set(pow(i, phi_coprime, n) for i in range(1, rounds))
    return roots, phi_coprime

roots,phi = roots_of_unity(e, n-1, n)
d = pow(e, -1,phi)
a = pow(ct,d,n)
for root in roots:
    flag = long_to_bytes((root*a) % n)
    if b'crypto' in flag:
        print(flag) 
```

either way ... 

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/b963abcd-e557-4c0b-be01-72047b13ef99)


<br><br><br>
***
<br><br><br>

# Square Eyes

### Description :
```
It was taking forever to get a 2048 bit prime, so I just generated one and used it twice.
```
```
n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896
```

### Solution :

now the first thing I thought was, n = p * p. \
So why not just do p =sqrt(n) \
and then phi = (p-1)*(p-1)

I tried that, but this is what I got at the end \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/239ee607-4dab-4107-b0c9-cc9e5c5c6ad8)

the p i got from square rooting was alright, it was prime. 
and this was hinting at something related to this issue im having im pretty sure. 
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/63eb75cf-b3eb-46ab-a92b-5f3dde8e5ba7)


so I set out to search what would phi(n) be for n = p^2

and I found gold at https://www.whitman.edu/mathematics/higher_math_online/section03.08.html

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/527f956d-5104-45ff-a72c-0edf116f194d)

i have a similar situation. I want phi(p^2)
therefore. `phi(p^2) = p^2-p`

```python
from Crypto.Util.number import *
import sympy as sp

n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896

p = int(sp.sqrt(n))
#p = 23148667521998097720857168827790771337662483716348435477360567409355026169165934446949809664595523770853897203103759106983985113264049057416908191166720008503275951625738975666019029172377653170602440373579593292576530667773951407647222757756437867216095193174201323278896027294517792607881861855264600525772460745259440301156930943255240915685718552334192230264780355799179037816026330705422484000086542362084006958158550346395941862383925942033730030004606360308379776255436206440529441711859246811586652746028418496020145441513037535475380962562108920699929022900677901988508936509354385660735694568216631382653107
phi = (p**2) - p
d = inverse(e,phi)
pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/68c06e4b-38ba-47a8-a7e6-c0d1425b7eff)

<br><br><br>
***
<br><br><br>

# Manyprime

### Description :
```
Using one prime factor was definitely a bad idea so I'll try using over 30 instead.
```
```
n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464
```

### Solution :

not gonna lie, I was spoiled on this chall months ago during LACTF \
where my chad chad seniors told me about a chall on cryptohack similar to the one I was attempting then. \
Manyprime. I have the source code to solve this. but I did look up why and how it works \
and this is how i thiink it works 
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/4f3bb96c-544c-4dd6-a008-4145c95d4ce6)

basically n = p * q * r * s * t * ... \
where p,q,r,s,t are all primes, and also relatively prime to each other. \
thus phi(n) = phi(p) * phi(q) * phi(r) * phi(s) * ... \
=> phi(n) = (p-1) * (q-1) * (r-1) * ...

```python
from Crypto.Util.number import *
import sympy as sp
from factordb.factordb import FactorDB

n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

phi = 1
for i in range(len(primes)):
    phi *= primes[i] - 1

d = inverse(e,phi)
pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/16027cee-ea50-439c-b5dd-69788835c9ea)


<br><br><br>
***
<br><br><br>

# Salty

### Description :
```
Smallest exponent should be fastest, right?
```
```
n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
e = 1
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485
```

### Solution :

I realised later that I overthought this and it was as easy as ciphertext = plaintext \
but oh well, still got the flag. here's what I did \
so e = 1
and we know, e*d = 1%phi
==> d = 1%phi ==> `d=1`
so flag = pow(ct,d,n)
(*which is the same as ct^d %n i.e ct%n = ct*)

```python
from Crypto.Util.number import *
import sympy as sp
from factordb.factordb import FactorDB

n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
e = 1
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485

d = 1
pt = pow(ct,d,n)
print(long_to_bytes(pt))

# or just print(long_to_bytes(ct)) ;-;
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/aee295b8-1973-44c3-9f7d-0820752f7efd)


<br><br><br>
***
<br><br><br>

# Modulus Inutilis

### Description : 
```
My primes should be more than large enough now!
```
```
n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957
```
```
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes

e = 3
d = -1

while d == -1:
    p = getPrime(1024)
    q = getPrime(1024)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag
```

### Solution :

dear old e=3 reminded me of picoCTF mini-rsa \
c = m^3 % n \
and m^3 definitely << n since in this chall the guy made sure to get big primes \
therefore... c = m^3 \
just need to cube root c.

```
from Crypto.Util.number import *
import sympy as sp
from sympy.functions.elementary.miscellaneous import cbrt

n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

print(long_to_bytes(cbrt(ct)))
```


<br><br><br>
***
<br><br><br>

# Everything Is Big

### Description :
```
We have a supercomputer at work, so I've made sure my encryption is secure by picking massive numbers!
```
```
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, bytes_to_long

FLAG = b"crypto{?????????????????????????}"

m = bytes_to_long(FLAG)

def get_huge_RSA():
    p = getPrime(1024)
    q = getPrime(1024)
    N = p*q
    phi = (p-1)*(q-1)
    while True:
        d = getPrime(256)
        e = pow(d,-1,phi)
        if e.bit_length() == N.bit_length():
            break
    return N,e


N, e = get_huge_RSA()
c = pow(m, e, N)

print(f'N = {hex(N)}')
print(f'e = {hex(e)}')
print(f'c = {hex(c)}')
```
```
N = 0xb8af3d3afb893a602de4afe2a29d7615075d1e570f8bad8ebbe9b5b9076594cf06b6e7b30905b6420e950043380ea746f0a14dae34469aa723e946e484a58bcd92d1039105871ffd63ffe64534b7d7f8d84b4a569723f7a833e6daf5e182d658655f739a4e37bd9f4a44aff6ca0255cda5313c3048f56eed5b21dc8d88bf5a8f8379eac83d8523e484fa6ae8dbcb239e65d3777829a6903d779cd2498b255fcf275e5f49471f35992435ee7cade98c8e82a8beb5ce1749349caa16759afc4e799edb12d299374d748a9e3c82e1cc983cdf9daec0a2739dadcc0982c1e7e492139cbff18c5d44529407edfd8e75743d2f51ce2b58573fea6fbd4fe25154b9964d
e = 0x9ab58dbc8049b574c361573955f08ea69f97ecf37400f9626d8f5ac55ca087165ce5e1f459ef6fa5f158cc8e75cb400a7473e89dd38922ead221b33bc33d6d716fb0e4e127b0fc18a197daf856a7062b49fba7a86e3a138956af04f481b7a7d481994aeebc2672e500f3f6d8c581268c2cfad4845158f79c2ef28f242f4fa8f6e573b8723a752d96169c9d885ada59cdeb6dbe932de86a019a7e8fc8aeb07748cfb272bd36d94fe83351252187c2e0bc58bb7a0a0af154b63397e6c68af4314601e29b07caed301b6831cf34caa579eb42a8c8bf69898d04b495174b5d7de0f20cf2b8fc55ed35c6ad157d3e7009f16d6b61786ee40583850e67af13e9d25be3
c = 0x3f984ff5244f1836ed69361f29905ca1ae6b3dcf249133c398d7762f5e277919174694293989144c9d25e940d2f66058b2289c75d1b8d0729f9a7c4564404a5fd4313675f85f31b47156068878e236c5635156b0fa21e24346c2041ae42423078577a1413f41375a4d49296ab17910ae214b45155c4570f95ca874ccae9fa80433a1ab453cbb28d780c2f1f4dc7071c93aff3924d76c5b4068a0371dff82531313f281a8acadaa2bd5078d3ddcefcb981f37ff9b8b14c7d9bf1accffe7857160982a2c7d9ee01d3e82265eec9c7401ecc7f02581fd0d912684f42d1b71df87a1ca51515aab4e58fab4da96e154ea6cdfb573a71d81b2ea4a080a1066e1bc3474
```

### Solution :

Immediate issue was the huuge e. \
instantly googles rsa when e huuge.
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/760fd68c-a21f-4b5b-9c1b-cb664af3aaaa)

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/103a9822-9e27-4de3-8b69-de00cba9d6ad)

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/96bf376e-db8c-4703-88d2-3fc9570d05b2)

after a good while, with the power of googling, I cooked this : \
```python
from Crypto.Util.number import *
from sympy import *

n = 0xb8af3d3afb893a602de4afe2a29d7615075d1e570f8bad8ebbe9b5b9076594cf06b6e7b30905b6420e950043380ea746f0a14dae34469aa723e946e484a58bcd92d1039105871ffd63ffe64534b7d7f8d84b4a569723f7a833e6daf5e182d658655f739a4e37bd9f4a44aff6ca0255cda5313c3048f56eed5b21dc8d88bf5a8f8379eac83d8523e484fa6ae8dbcb239e65d3777829a6903d779cd2498b255fcf275e5f49471f35992435ee7cade98c8e82a8beb5ce1749349caa16759afc4e799edb12d299374d748a9e3c82e1cc983cdf9daec0a2739dadcc0982c1e7e492139cbff18c5d44529407edfd8e75743d2f51ce2b58573fea6fbd4fe25154b9964d
e = 0x9ab58dbc8049b574c361573955f08ea69f97ecf37400f9626d8f5ac55ca087165ce5e1f459ef6fa5f158cc8e75cb400a7473e89dd38922ead221b33bc33d6d716fb0e4e127b0fc18a197daf856a7062b49fba7a86e3a138956af04f481b7a7d481994aeebc2672e500f3f6d8c581268c2cfad4845158f79c2ef28f242f4fa8f6e573b8723a752d96169c9d885ada59cdeb6dbe932de86a019a7e8fc8aeb07748cfb272bd36d94fe83351252187c2e0bc58bb7a0a0af154b63397e6c68af4314601e29b07caed301b6831cf34caa579eb42a8c8bf69898d04b495174b5d7de0f20cf2b8fc55ed35c6ad157d3e7009f16d6b61786ee40583850e67af13e9d25be3
c = 0x3f984ff5244f1836ed69361f29905ca1ae6b3dcf249133c398d7762f5e277919174694293989144c9d25e940d2f66058b2289c75d1b8d0729f9a7c4564404a5fd4313675f85f31b47156068878e236c5635156b0fa21e24346c2041ae42423078577a1413f41375a4d49296ab17910ae214b45155c4570f95ca874ccae9fa80433a1ab453cbb28d780c2f1f4dc7071c93aff3924d76c5b4068a0371dff82531313f281a8acadaa2bd5078d3ddcefcb981f37ff9b8b14c7d9bf1accffe7857160982a2c7d9ee01d3e82265eec9c7401ecc7f02581fd0d912684f42d1b71df87a1ca51515aab4e58fab4da96e154ea6cdfb573a71d81b2ea4a080a1066e1bc3474

def cont_fracs(x,y):
    # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an]
    a = x // y
    pquotients = [a]
    while a * y != x:
        x, y = y, x - a * y
        a = x // y
        pquotients.append(a)
    return pquotients

def contfrac_to_rational (frac):
    # Converts a finite continued fraction [a0, ..., an] to an x/y rational.
    if len(frac) == 0: return (0,1)
    num = frac[-1]
    denom = 1
    for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num
    return (num, denom)

def convergents(frac):
    # computes the list of convergents from some [a0, ..., an]
    convs = []
    for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i]))
    return convs

def getthed(e, n):
    frac = cont_fracs(e, n)
    cgts = convergents(frac)
    
    for (k, d) in cgts:
        if k != 0 and (e * d - 1) % k == 0:
            phi = (e * d - 1) // k
            s = n - phi + 1
            # check if x*x - s*x + n = 0 has integer roots
            D = s * s - 4 * n
            if D >= 0:
                sq = sqrt(D)
                if sq * sq == D and (s + sq) % 2 == 0: return d

d = getthed(e,n)
print(long_to_bytes(pow(c,d,n)))
```

<br><br><br>
***
<br><br><br>

# Crossed Wires

### Description :

```
I asked my friends to encrypt our secret flag before sending it to me, but instead of using my key, they've all used their own! Can you help?
```
```
from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long, inverse
import math
from gmpy2 import next_prime

FLAG = b"crypto{????????????????????????????????????????????????}"

p = getPrime(1024)
q = getPrime(1024)
N = p*q
phi = (p-1)*(q-1)
e = 0x10001
d = inverse(e, phi)

my_key = (N, d)

friends = 5
friend_keys = [(N, getPrime(17)) for _ in range(friends)]

cipher = bytes_to_long(FLAG)

for key in friend_keys:
    cipher = pow(cipher, key[1], key[0])

print(f"My private key: {my_key}")
print(f"My Friend's public keys: {friend_keys}")
print(f"Encrypted flag: {cipher}")
```
```
My private key: (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097)
My Friend's public keys: [(21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 106979), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 108533), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 69557), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 97117), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 103231)]
Encrypted flag: 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
```
### Solution :

So we are given (N,d) and a list of [(N,e1),(N,e2),(N,e3)...] \
I know those are es even thought the guy calls their keys i.e ds \
because : 
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/2ba8508a-499c-4361-b181-0d48c7147900)
they are exponents


and we also given this handy dandy thing \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/fc7631ef-f5b1-419d-aae1-c709a83445a7)

I followed this directly and found p,q \
then found phi, and decrypted the ciphertext 5 times wit a pow(e,d,N) with e for each friend's e 

```python
from Crypto.Util.number import *
import random

c = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
d = 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097
dost_ke_chaabi = [(21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 106979), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 108533), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 69557), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 97117), (21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771, 103231)]
fkeys = dost_ke_chaabi[::-1]
e = 0x10001
N = 21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771

def find_p_q():
    k = e*d - 1
    while True:
        t = k
        g = random.randint(2,N-1)
        while t%2 ==0:
            t = t//2
            x = pow(g,t,N)
            y = GCD(x-1, N)
            if x > 1 and y>1 :
                p = y
                q = N//y
                print(p)
                print(q)
                return p,q
            else:
                continue

p,q = find_p_q()
phi = (p-1)*(q-1)
# print(isPrime(p))
# print(isPrime(q))

for e in fkeys:
    d = inverse(e[1], phi)
    c = pow(c,d,N)

print(long_to_bytes(c))
```
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/ed326b2e-1b9b-4f8c-b8c1-8eb290164651)


<br><br><br>
***
<br><br><br>

# Everything is Still Big

### Description :
```
Okay so I got a bit carefree with my last script, but this time I've protected myself while keeping everything really big. Nothing will stop me and my supercomputer now!
```
```
N = 0xb12746657c720a434861e9a4828b3c89a6b8d4a1bd921054e48d47124dbcc9cfcdcc39261c5e93817c167db818081613f57729e0039875c72a5ae1f0bc5ef7c933880c2ad528adbc9b1430003a491e460917b34c4590977df47772fab1ee0ab251f94065ab3004893fe1b2958008848b0124f22c4e75f60ed3889fb62e5ef4dcc247a3d6e23072641e62566cd96ee8114b227b8f498f9a578fc6f687d07acdbb523b6029c5bbeecd5efaf4c4d35304e5e6b5b95db0e89299529eb953f52ca3247d4cd03a15939e7d638b168fd00a1cb5b0cc5c2cc98175c1ad0b959c2ab2f17f917c0ccee8c3fe589b4cb441e817f75e575fc96a4fe7bfea897f57692b050d2b
e = 0x9d0637faa46281b533e83cc37e1cf5626bd33f712cc1948622f10ec26f766fb37b9cd6c7a6e4b2c03bce0dd70d5a3a28b6b0c941d8792bc6a870568790ebcd30f40277af59e0fd3141e272c48f8e33592965997c7d93006c27bf3a2b8fb71831dfa939c0ba2c7569dd1b660efc6c8966e674fbe6e051811d92a802c789d895f356ceec9722d5a7b617d21b8aa42dd6a45de721953939a5a81b8dffc9490acd4f60b0c0475883ff7e2ab50b39b2deeedaefefffc52ae2e03f72756d9b4f7b6bd85b1a6764b31312bc375a2298b78b0263d492205d2a5aa7a227abaf41ab4ea8ce0e75728a5177fe90ace36fdc5dba53317bbf90e60a6f2311bb333bf55ba3245f
c = 0xa3bce6e2e677d7855a1a7819eb1879779d1e1eefa21a1a6e205c8b46fdc020a2487fdd07dbae99274204fadda2ba69af73627bdddcb2c403118f507bca03cb0bad7a8cd03f70defc31fa904d71230aab98a10e155bf207da1b1cac1503f48cab3758024cc6e62afe99767e9e4c151b75f60d8f7989c152fdf4ff4b95ceed9a7065f38c68dee4dd0da503650d3246d463f504b36e1d6fafabb35d2390ecf0419b2bb67c4c647fb38511b34eb494d9289c872203fa70f4084d2fa2367a63a8881b74cc38730ad7584328de6a7d92e4ca18098a15119baee91237cea24975bdfc19bdbce7c1559899a88125935584cd37c8dd31f3f2b4517eefae84e7e588344fa5
```
```python
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, bytes_to_long, inverse
from random import getrandbits
from math import gcd

FLAG = b"crypto{?????????????????????????????????????}"

m = bytes_to_long(FLAG)

def get_huge_RSA():
    p = getPrime(1024)
    q = getPrime(1024)
    N = p*q
    phi = (p-1)*(q-1)
    while True:
        d = getrandbits(512)
        if (3*d)**4 > N and gcd(d,phi) == 1:
            e = inverse(d, phi)
            break
    return N,e


N, e = get_huge_RSA()
c = pow(m, e, N)

print(f'N = {hex(N)}')
print(f'e = {hex(e)}')
print(f'c = {hex(c)}')
```

### Solution :

So similar to `everything is big`, I figured there wasn't much difference... e was even being decided based on the condition :
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/0520cc6e-d922-42d6-970e-6e4ba68ec8f2)

So I just re-used my weiners attack script from above. \
it worked, but..
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/b9b9104d-0659-4059-b49e-076b84a751ea)

from the flag I figured I was supposed to use boneh's for this. \
So I set out looking for how boneh works.


<br><br><br>
***
<br><br><br>

# Endless Emails

### Description :
```
Poor Johan has been answering emails all day and the students are all asking the same questions. Can you read his messages?
```

### Solution :

we got a bunch of ns,cs, and e=3. crt whispered into my brain. \
Ive seen this thing too many times, time to properly understand it. \

even in the material they've given it seems hastads attack is the way to do this.

I already had a hastad script made from a previous ctf

there was a catch here tho, for hastad to work, it should have 'e' amount of Ns and Cs 

here, e=3 but we have 7 pairs of Ns and Cs

so just take up the first 3 pairs right ? \
no that didnt work I got rando bullshite. 

but a certain three pairs of ns and cs should work. \
I reiterated through every combination of the ns and cs pair

and yes :
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/f8503fbf-2e11-485d-9b86-e5baa5bf56e4)

wait, better version
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/137d5c9c-45ae-4db1-a413-885160f50ab7)



```python
from functools import reduce
import gmpy2
from pwn import *
from Crypto.Util.number import *
from itertools import combinations

n1 = 14528915758150659907677315938876872514853653132820394367681510019000469589767908107293777996420037715293478868775354645306536953789897501630398061779084810058931494642860729799059325051840331449914529594113593835549493208246333437945551639983056810855435396444978249093419290651847764073607607794045076386643023306458718171574989185213684263628336385268818202054811378810216623440644076846464902798568705083282619513191855087399010760232112434412274701034094429954231366422968991322244343038458681255035356984900384509158858007713047428143658924970374944616430311056440919114824023838380098825914755712289724493770021
e = 3
c1 = 6965891612987861726975066977377253961837139691220763821370036576350605576485706330714192837336331493653283305241193883593410988132245791554283874785871849223291134571366093850082919285063130119121338290718389659761443563666214229749009468327825320914097376664888912663806925746474243439550004354390822079954583102082178617110721589392875875474288168921403550415531707419931040583019529612270482482718035497554779733578411057633524971870399893851589345476307695799567919550426417015815455141863703835142223300228230547255523815097431420381177861163863791690147876158039619438793849367921927840731088518955045807722225


n2 = 20463913454649855046677206889944639231694511458416906994298079596685813354570085475890888433776403011296145408951323816323011550738170573801417972453504044678801608709931200059967157605416809387753258251914788761202456830940944486915292626560515250805017229876565916349963923702612584484875113691057716315466239062005206014542088484387389725058070917118549621598629964819596412564094627030747720659155558690124005400257685883230881015636066183743516494701900125788836869358634031031172536767950943858472257519195392986989232477630794600444813136409000056443035171453870906346401936687214432176829528484662373633624123
e = 3
c2 = 5109363605089618816120178319361171115590171352048506021650539639521356666986308721062843132905170261025772850941702085683855336653472949146012700116070022531926476625467538166881085235022484711752960666438445574269179358850309578627747024264968893862296953506803423930414569834210215223172069261612934281834174103316403670168299182121939323001232617718327977313659290755318972603958579000300780685344728301503641583806648227416781898538367971983562236770576174308965929275267929379934367736694110684569576575266348020800723535121638175505282145714117112442582416208209171027273743686645470434557028336357172288865172


n3 = 19402640770593345339726386104915705450969517850985511418263141255686982818547710008822417349818201858549321868878490314025136645036980129976820137486252202687238348587398336652955435182090722844668488842986318211649569593089444781595159045372322540131250208258093613844753021272389255069398553523848975530563989367082896404719544411946864594527708058887475595056033713361893808330341623804367785721774271084389159493974946320359512776328984487126583015777989991635428744050868653379191842998345721260216953918203248167079072442948732000084754225272238189439501737066178901505257566388862947536332343196537495085729147
e = 3
c3 = 5603386396458228314230975500760833991383866638504216400766044200173576179323437058101562931430558738148852367292802918725271632845889728711316688681080762762324367273332764959495900563756768440309595248691744845766607436966468714038018108912467618638117493367675937079141350328486149333053000366933205635396038539236203203489974033629281145427277222568989469994178084357460160310598260365030056631222346691527861696116334946201074529417984624304973747653407317290664224507485684421999527164122395674469650155851869651072847303136621932989550786722041915603539800197077294166881952724017065404825258494318993054344153


n4 = 12005639978012754274325188681720834222130605634919280945697102906256738419912110187245315232437501890545637047506165123606573171374281507075652554737014979927883759915891863646221205835211640845714836927373844277878562666545230876640830141637371729405545509920889968046268135809999117856968692236742804637929866632908329522087977077849045608566911654234541526643235586433065170392920102840518192803854740398478305598092197183671292154743153130012885747243219372709669879863098708318993844005566984491622761795349455404952285937152423145150066181043576492305166964448141091092142224906843816547235826717179687198833961
e = 3
c4 = 1522280741383024774933280198410525846833410931417064479278161088248621390305797210285777845359812715909342595804742710152832168365433905718629465545306028275498667935929180318276445229415104842407145880223983428713335709038026249381363564625791656631137936935477777236936508600353416079028339774876425198789629900265348122040413865209592074731028757972968635601695468594123523892918747882221891834598896483393711851510479989203644477972694520237262271530260496342247355761992646827057846109181410462131875377404309983072358313960427035348425800940661373272947647516867525052504539561289941374722179778872627956360577


n5 = 17795451956221451086587651307408104001363221003775928432650752466563818944480119932209305765249625841644339021308118433529490162294175590972336954199870002456682453215153111182451526643055812311071588382409549045943806869173323058059908678022558101041630272658592291327387549001621625757585079662873501990182250368909302040015518454068699267914137675644695523752851229148887052774845777699287718342916530122031495267122700912518207571821367123013164125109174399486158717604851125244356586369921144640969262427220828940652994276084225196272504355264547588369516271460361233556643313911651916709471353368924621122725823
e = 3
c5 = 8752507806125480063647081749506966428026005464325535765874589376572431101816084498482064083887400646438977437273700004934257274516197148448425455243811009944321764771392044345410680448204581679548854193081394891841223548418812679441816502910830861271884276608891963388657558218620911858230760629700918375750796354647493524576614017731938584618983084762612414591830024113057983483156974095503392359946722756364412399187910604029583464521617256125933111786441852765229820406911991809039519015434793656710199153380699319611499255869045311421603167606551250174746275803467549814529124250122560661739949229005127507540805


n6 = 25252721057733555082592677470459355315816761410478159901637469821096129654501579313856822193168570733800370301193041607236223065376987811309968760580864569059669890823406084313841678888031103461972888346942160731039637326224716901940943571445217827960353637825523862324133203094843228068077462983941899571736153227764822122334838436875488289162659100652956252427378476004164698656662333892963348126931771536472674447932268282205545229907715893139346941832367885319597198474180888087658441880346681594927881517150425610145518942545293750127300041942766820911120196262215703079164895767115681864075574707999253396530263
e = 3
c6 = 23399624135645767243362438536844425089018405258626828336566973656156553220156563508607371562416462491581383453279478716239823054532476006642583363934314982675152824147243749715830794488268846671670287617324522740126594148159945137948643597981681529145611463534109482209520448640622103718682323158039797577387254265854218727476928164074249568031493984825273382959147078839665114417896463735635546290504843957780546550577300001452747760982468547756427137284830133305010038339400230477403836856663883956463830571934657200851598986174177386323915542033293658596818231793744261192870485152396793393026198817787033127061749


n7 = 19833203629283018227011925157509157967003736370320129764863076831617271290326613531892600790037451229326924414757856123643351635022817441101879725227161178559229328259469472961665857650693413215087493448372860837806619850188734619829580286541292997729705909899738951228555834773273676515143550091710004139734080727392121405772911510746025807070635102249154615454505080376920778703360178295901552323611120184737429513669167641846902598281621408629883487079110172218735807477275590367110861255756289520114719860000347219161944020067099398239199863252349401303744451903546571864062825485984573414652422054433066179558897
e = 3
c7 = 15239683995712538665992887055453717247160229941400011601942125542239446512492703769284448009141905335544729440961349343533346436084176947090230267995060908954209742736573986319254695570265339469489948102562072983996668361864286444602534666284339466797477805372109723178841788198177337648499899079471221924276590042183382182326518312979109378616306364363630519677884849945606288881683625944365927809405420540525867173639222696027472336981838588256771671910217553150588878434061862840893045763456457939944572192848992333115479951110622066173007227047527992906364658618631373790704267650950755276227747600169403361509144

def crt(items):
    N = 1               # N = na * nb * nc
    for i in items:
        N *= i[1]
    result = sum((N // item[1]) * gmpy2.invert(N // item[1], item[1]) * item[0] for item in items) % N
    return result

def hastads_broadcast_attack(ciphertexts, moduli, e):

    crt_result = crt(list(zip(ciphertexts, moduli)))
    plaintext = gmpy2.iroot(crt_result, e)[0]
    return int(plaintext)

the_seven_Cs = [c1,c2,c3,c4,c5,c6,c7]
the_seven_Ns = [n1,n2,n3,n4,n5,n6,n7]

# but for hastads to work, number of moduli = number of ciphertexts = e

# there are multiple possibilities of a n1,n2,n3 c1,c2,c3 pair

for i in list(combinations(zip(the_seven_Cs,the_seven_Ns),3)):
    ns = [x[1] for x in i]
    cs = [x[0] for x in i]
    
    e = 3
    flag = hastads_broadcast_attack(cs, ns, e)
    if b"crypto" in long_to_bytes(flag):
        print(long_to_bytes(flag).decode())
```


<br><br><br>
***
<br><br><br>

# Infinite Descent

### Description :
```
Finding large primes is slow, so I've devised an optimisation.
```
### Solution :

Literally directly factored n and got it

```python
from Crypto.Util.number import *
from factordb.factordb import FactorDB

n = 383347712330877040452238619329524841763392526146840572232926924642094891453979246383798913394114305368360426867021623649667024217266529000859703542590316063318592391925062014229671423777796679798747131250552455356061834719512365575593221216339005132464338847195248627639623487124025890693416305788160905762011825079336880567461033322240015771102929696350161937950387427696385850443727777996483584464610046380722736790790188061964311222153985614287276995741553706506834906746892708903948496564047090014307484054609862129530262108669567834726352078060081889712109412073731026030466300060341737504223822014714056413752165841749368159510588178604096191956750941078391415634472219765129561622344109769892244712668402761549412177892054051266761597330660545704317210567759828757156904778495608968785747998059857467440128156068391746919684258227682866083662345263659558066864109212457286114506228470930775092735385388316268663664139056183180238043386636254075940621543717531670995823417070666005930452836389812129462051771646048498397195157405386923446893886593048680984896989809135802276892911038588008701926729269812453226891776546037663583893625479252643042517196958990266376741676514631089466493864064316127648074609662749196545969926051
e = 65537
c = 98280456757136766244944891987028935843441533415613592591358482906016439563076150526116369842213103333480506705993633901994107281890187248495507270868621384652207697607019899166492132408348789252555196428608661320671877412710489782358282011364127799563335562917707783563681920786994453004763755404510541574502176243896756839917991848428091594919111448023948527766368304503100650379914153058191140072528095898576018893829830104362124927140555107994114143042266758709328068902664037870075742542194318059191313468675939426810988239079424823495317464035252325521917592045198152643533223015952702649249494753395100973534541766285551891859649320371178562200252228779395393974169736998523394598517174182142007480526603025578004665936854657294541338697513521007818552254811797566860763442604365744596444735991732790926343720102293453429936734206246109968817158815749927063561835274636195149702317415680401987150336994583752062565237605953153790371155918439941193401473271753038180560129784192800351649724465553733201451581525173536731674524145027931923204961274369826379325051601238308635192540223484055096203293400419816024111797903442864181965959247745006822690967920957905188441550106930799896292835287867403979631824085790047851383294389

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

# print(primes)

p = primes[0]
q = primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)
pt = pow(c,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/1588cf4a-11df-4c86-840d-939fcb014a67)


<br><br><br>
***
<br><br><br>

# Marin's Secrets

### Description :
```
I've found a super fast way to generate primes from my secret list.
```

### Solution :

bro factordb too op

```python
from Crypto.Util.number import *
from factordb.factordb import FactorDB


n= 658416274830184544125027519921443515789888264156074733099244040126213682497714032798116399288176502462829255784525977722903018714434309698108208388664768262754316426220651576623731617882923164117579624827261244506084274371250277849351631679441171018418018498039996472549893150577189302871520311715179730714312181456245097848491669795997289830612988058523968384808822828370900198489249243399165125219244753790779764466236965135793576516193213175061401667388622228362042717054014679032953441034021506856017081062617572351195418505899388715709795992029559042119783423597324707100694064675909238717573058764118893225111602703838080618565401139902143069901117174204252871948846864436771808616432457102844534843857198735242005309073939051433790946726672234643259349535186268571629077937597838801337973092285608744209951533199868228040004432132597073390363357892379997655878857696334892216345070227646749851381208554044940444182864026513709449823489593439017366358869648168238735087593808344484365136284219725233811605331815007424582890821887260682886632543613109252862114326372077785369292570900594814481097443781269562647303671428895764224084402259605109600363098950091998891375812839523613295667253813978434879172781217285652895469194181218343078754501694746598738215243769747956572555989594598180639098344891175879455994652382137038240166358066403475457 
e= 65537
c= 400280463088930432319280359115194977582517363610532464295210669530407870753439127455401384569705425621445943992963380983084917385428631223046908837804126399345875252917090184158440305503817193246288672986488987883177380307377025079266030262650932575205141853413302558460364242355531272967481409414783634558791175827816540767545944534238189079030192843288596934979693517964655661507346729751987928147021620165009965051933278913952899114253301044747587310830419190623282578931589587504555005361571572561916866063458812965314474160499067525067495140150092119620928363007467390920130717521169105167963364154636472055084012592138570354390246779276003156184676298710746583104700516466091034510765027167956117869051938116457370384737440965109619578227422049806566060571831017610877072484262724789571076529586427405780121096546942812322324807145137017942266863534989082115189065560011841150908380937354301243153206428896320576609904361937035263985348984794208198892615898907005955403529470847124269512316191753950203794578656029324506688293446571598506042198219080325747328636232040936761788558421528960279832802127562115852304946867628316502959562274485483867481731149338209009753229463924855930103271197831370982488703456463385914801246828662212622006947380115549529820197355738525329885232170215757585685484402344437894981555179129287164971002033759724456

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

print(primes)

p = primes[0]
q = primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)
pt = pow(c,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/2a1a9d6b-db06-49f6-a9d0-39a0422a67ea)


<br><br><br>
***
<br><br><br>

# RSA Backdoor-viability

### Description :
```
It seems like my method to generate fast primes was not completely secure. I came up with a new approach to improve security, including a factorization backdoor in case I ever lose my private key. You'll definitely need some complex techniques to break this!
```

### Solution :

factored again

```python
from Crypto.Util.number import *
from factordb.factordb import FactorDB

n = 709872443186761582125747585668724501268558458558798673014673483766300964836479167241315660053878650421761726639872089885502004902487471946410918420927682586362111137364814638033425428214041019139158018673749256694555341525164012369589067354955298579131735466795918522816127398340465761406719060284098094643289390016311668316687808837563589124091867773655044913003668590954899705366787080923717270827184222673706856184434629431186284270269532605221507485774898673802583974291853116198037970076073697225047098901414637433392658500670740996008799860530032515716031449787089371403485205810795880416920642186451022374989891611943906891139047764042051071647203057520104267427832746020858026150611650447823314079076243582616371718150121483335889885277291312834083234087660399534665835291621232056473843224515909023120834377664505788329527517932160909013410933312572810208043849529655209420055180680775718614088521014772491776654380478948591063486615023605584483338460667397264724871221133652955371027085804223956104532604113969119716485142424996255737376464834315527822566017923598626634438066724763559943441023574575168924010274261376863202598353430010875182947485101076308406061724505065886990350185188453776162319552566614214624361251463
e = 65537
c = 608484617316138126443275660524263025508135383745665175433229598517433030003704261658172582370543758277685547533834085899541036156595489206369279739210904154716464595657421948607569920498815631503197235702333017824993576326860166652845334617579798536442066184953550975487031721085105757667800838172225947001224495126390587950346822978519677673568121595427827980195332464747031577431925937314209391433407684845797171187006586455012364702160988147108989822392986966689057906884691499234298351003666019957528738094330389775054485731448274595330322976886875528525229337512909952391041280006426003300720547721072725168500104651961970292771382390647751450445892361311332074663895375544959193148114635476827855327421812307562742481487812965210406231507524830889375419045542057858679609265389869332331811218601440373121797461318931976890674336807528107115423915152709265237590358348348716543683900084640921475797266390455366908727400038393697480363793285799860812451995497444221674390372255599514578194487523882038234487872223540513004734039135243849551315065297737535112525440094171393039622992561519170849962891645196111307537341194621689797282496281302297026025131743423205544193536699103338587843100187637572006174858230467771942700918388

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

p = primes[0]
q = primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)
pt = pow(c,d,n)
print(long_to_bytes(pt))
```
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/b71f2208-26d6-41b3-a6aa-5982612d714a)


<br><br><br>
***
<br><br><br>

# Fast Primes

### Description :
```
I need to produce millions of RSA keys quickly and the standard way just doesn't cut it. Here's yet another fast way to generate primes which has actually resisted years of review.
```

### Solution :
So few things going on here : \
1. primes generated using this method called Sieve of Sundaram, which has been well explained in the function itself \
```python
def sieve(maximum=10000):
    # In general Sieve of Sundaram, produces primes smaller
    # than (2*x + 2) for a number given number x. Since
    # we want primes smaller than maximum, we reduce maximum to half
    # This array is used to separate numbers of the form
    # i+j+2ij from others where 1 <= i <= j
    marked = [False]*(int(maximum/2)+1)

    # Main logic of Sundaram. Mark all numbers which
    # do not generate prime number by doing 2*i+1
    for i in range(1, int((math.sqrt(maximum)-1)/2)+1):
        for j in range(((i*(i+1)) << 1), (int(maximum/2)+1), (2*i+1)):
            marked[j] = True

    # Since 2 is a prime number
    primes.append(2)

    # Print other primes. Remaining primes are of the
    # form 2*i + 1 such that marked[i] is false.
    for i in range(1, int(maximum/2)):
        if (marked[i] == False):
            primes.append(2*i + 1)
    
def get_primorial(n):
    result = 1
    for i in range(n):
        result = result * primes[i]
    return result


def get_fast_prime():
    M = get_primorial(40)
    while True:
        k = random.randint(2**28, 2**29-1)
        a = random.randint(2**20, 2**62-1)
        p = k * M + pow(e, a, M)

        if is_prime(p):
            return p
```
2. we been given a publickey, an actual .pem format one.

Learnt how to extract info from rsa .pem publickey in CryptoHack General Challenges. \
I did just that, got N, factored and regular rsa decrypted.. but : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/e816e091-8071-4968-ba0f-0c1e5dbed274)

absolute bullshite. \
I went through the code and a while later I think I know whats wrong : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/cfee1be3-dd07-4719-b798-54f1a93a6e89)
`PKCS1_OAEP`, that's a padding scheme and it was being used on the ciphertext. \
I was researching how to undo PCKS1_OAEP padding when I saw this in the code : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/651502b6-85fb-45ef-87a8-145b6c326dca)

bruh

the decryption's literally there `assert cipher.decrypt(ciphertext) == FLAG`

I did just that \
```python
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Util.number import *
from factordb.factordb import FactorDB

with open(r"C:\Users\madha\Downloads\key_17a08b7040db46308f8b9a19894f9f95.pem", 'r') as f:
    pubkey = RSA.import_key(f.read())

ct = bytes.fromhex("249d72cd1d287b1a15a3881f2bff5788bc4bf62c789f2df44d88aae805b54c9a94b8944c0ba798f70062b66160fee312b98879f1dd5d17b33095feb3c5830d28")
n = pubkey.n
e = pubkey.e
# print(n)

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()
p,q = primes[0],primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)

key = RSA.construct((n, e, d))
cipher = PKCS1_OAEP.new(key)

pt = cipher.decrypt(ct)
print(pt)
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/aa37e5f9-458f-469b-bb60-d5a84df8b2e8)


<br><br><br>
***
<br><br><br>

# Ron was Wrong, Whit is Right

### Description :
```
Here's a bunch of RSA public keys I gathered from people on the net together with messages that they sent.

As excerpt.py shows, everyone was using PKCS#1 OAEP to encrypt their own messages. It shouldn't be possible to decrypt them, but perhaps there are issues with some of the keys?
```
```python
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA


msg = "???"

with open('21.pem') as f:
    key = RSA.importKey(f.read())

cipher = PKCS1_OAEP.new(key)
ciphertext = cipher.encrypt(msg)

with open('21.ciphertext', 'w') as f:
    f.write(ciphertext.hex())
```

### Solution :

About directly solved this, we know where ciphertext is `21.ciphertext` and we know the publickey `21.pem` \
and luckily enough N got factorised with factordb. \
```python
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from factordb.factordb import FactorDB
from Crypto.Cipher import PKCS1_OAEP

ct = bytes.fromhex('c62d91677825632cb8ac9d2fbee7490fca70b3f067bd8d811fa446a21001de7943cacafc429b2513d3f20c3224d212ca2937a4a4ea10792a1c498b791e978e4b050b525576bc68421e40d9f420c0b8a07778daf69edf2095bf48222896bb2d6581288ce7a2e7aec15a88a440ff1a1e48beb56f68b4f860d1f64a6ec8cafed90846b7d893bc482df69c8478d5a0d6fc2d043cdd97178740a9eb59d2576b5136200c8ea77e648c88e6c5104ca5d0c6add2fc2c8569ce909f8461e7fa3d901fe67eaeff656399d4751fedba9973e246427e0c7a217f5bdc3edcb5033f17b5ef53419e340355a809eb46f48f538e880abd6f72212b02d3dbf2c4f633a503e648d1a835c4574b23e329e1c51078ea7cbb7533e771899498d4a5760bc0799b7e046f268f098fe0b57de47cd70ccf01ad3c9daec5027f306141bfe7a6c0bd29ee6caf94c7433c25e34ee974005e2360337cb6b3cec5eaf5d31d19f01435f4cdcaa455a18e78dee078395b8ad14b9c3a0d817dc1e3109c7b8af35ab3a5950bf47d5e621f9373ef421540052aac307ecea91f9c29c14bfd81b41d4c5a9b34a8ec2fa1ae06c3d881f39286c3d8dbb1849602fecc27bb135f7dd443e2598d247d1182d350b04be1ac0a734cb0e852a36902d88066ac375a35e279b126e413a97aaa35a0ba933f7b8d574c298332ce428c181464b240709a414af1b77103441b6ccfd0790eccea5926844054903c83f4cb415d600a6b7bc771c9e7a86394a2b427ebe8edec08b8095f561827716898e11caf6f0fe562af8a69f7b6469f0e86bdcc32f429f10821c763b34307efc5b2ae7fd524a07e5d0b762c096f025a3f240fb7bd3554582dcce32c175867d93970b0422e17870ec58f2a305545a3d284b3abb2d21a45ad8fd5faed0dc66312a5aa2f994606a51cd6682acd48ea3fb883f0611e1e5c2fb4047b5c80815ba5d3bcfefaf121bfde4d5c91ee27bb899ef0d29fa5c6dc4223ac2bfcff0217d08579a13e9b02dc97aa2622df62eeaaa38bb3bd087cdd209f03e8926a951e90eaa0f678a252a067ac66402a4c85865931689ed3b33f9f6de0c499f140ef508dfba6007a607a271dcbec18a61f7488bba34d143f93bc259310ffbf23f3391734d8d8811a4be8abf6382e55c2ccbfd80b1559d907fd8d46e0431cdbcd8fdb06d57973437f7b8ff5efc5a53c80d552e8fe622971f7376eeea35f4df9b32ada93e531a52b63ba13f6b7bf61ab337d6d93feb0e8c8a309dfa7e5f50e8cf9655b73ae64822b50db5312f35f4718b0668305065ea283ddf8f0a4e8f486ee9d119ebc584be1837b3d959a25ace208ffac2fb703390a72d3027b64fdd1955b513c0403f09232efa1794a277e0be3f4f9f3a6fd23c6e52101e723cef5db7a2a18a107cd522379adb40c5ed36b26cdf53a1000d7d576f1157b42aac3d3ee011275')
with open(r"C:\Users\madha\Downloads\keys_and_messages_701dba5b1a84cb168547ec18227a7740\keys_and_messages\21.pem",'r') as f:
    key = RSA.import_key(f.read())

n = key.n
e = key.e
f = FactorDB(n)
f.connect()
primes = f.get_factor_list()
p,q = primes[0],primes[1]
phi = (p-1)*(q-1)
d = inverse(e,phi)

key = RSA.construct((n,e,d))
cipher = PKCS1_OAEP.new(key)
print(cipher.decrypt(ct))
```
but : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/9b5c1039-5629-4f0f-b8d3-62a73e55b318)
https://eprint.iacr.org/2012/064.pdf

After a while of going through this thing, I realised I probably wasn't supposed to solve it like i did. \
See the thing is, there was this exploit because people started reusing primes, if u had a big enough amount of Ns, \
you could factor out primes pretty easily by finding GCD(of current N, other Ns) if that gave anything other than 1 or N \
you would get p, and then q by N//p. \
I tried out this method and yes : 
```python
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

ct = bytes.fromhex('c62d91677825632cb8ac9d2fbee7490fca70b3f067bd8d811fa446a21001de7943cacafc429b2513d3f20c3224d212ca2937a4a4ea10792a1c498b791e978e4b050b525576bc68421e40d9f420c0b8a07778daf69edf2095bf48222896bb2d6581288ce7a2e7aec15a88a440ff1a1e48beb56f68b4f860d1f64a6ec8cafed90846b7d893bc482df69c8478d5a0d6fc2d043cdd97178740a9eb59d2576b5136200c8ea77e648c88e6c5104ca5d0c6add2fc2c8569ce909f8461e7fa3d901fe67eaeff656399d4751fedba9973e246427e0c7a217f5bdc3edcb5033f17b5ef53419e340355a809eb46f48f538e880abd6f72212b02d3dbf2c4f633a503e648d1a835c4574b23e329e1c51078ea7cbb7533e771899498d4a5760bc0799b7e046f268f098fe0b57de47cd70ccf01ad3c9daec5027f306141bfe7a6c0bd29ee6caf94c7433c25e34ee974005e2360337cb6b3cec5eaf5d31d19f01435f4cdcaa455a18e78dee078395b8ad14b9c3a0d817dc1e3109c7b8af35ab3a5950bf47d5e621f9373ef421540052aac307ecea91f9c29c14bfd81b41d4c5a9b34a8ec2fa1ae06c3d881f39286c3d8dbb1849602fecc27bb135f7dd443e2598d247d1182d350b04be1ac0a734cb0e852a36902d88066ac375a35e279b126e413a97aaa35a0ba933f7b8d574c298332ce428c181464b240709a414af1b77103441b6ccfd0790eccea5926844054903c83f4cb415d600a6b7bc771c9e7a86394a2b427ebe8edec08b8095f561827716898e11caf6f0fe562af8a69f7b6469f0e86bdcc32f429f10821c763b34307efc5b2ae7fd524a07e5d0b762c096f025a3f240fb7bd3554582dcce32c175867d93970b0422e17870ec58f2a305545a3d284b3abb2d21a45ad8fd5faed0dc66312a5aa2f994606a51cd6682acd48ea3fb883f0611e1e5c2fb4047b5c80815ba5d3bcfefaf121bfde4d5c91ee27bb899ef0d29fa5c6dc4223ac2bfcff0217d08579a13e9b02dc97aa2622df62eeaaa38bb3bd087cdd209f03e8926a951e90eaa0f678a252a067ac66402a4c85865931689ed3b33f9f6de0c499f140ef508dfba6007a607a271dcbec18a61f7488bba34d143f93bc259310ffbf23f3391734d8d8811a4be8abf6382e55c2ccbfd80b1559d907fd8d46e0431cdbcd8fdb06d57973437f7b8ff5efc5a53c80d552e8fe622971f7376eeea35f4df9b32ada93e531a52b63ba13f6b7bf61ab337d6d93feb0e8c8a309dfa7e5f50e8cf9655b73ae64822b50db5312f35f4718b0668305065ea283ddf8f0a4e8f486ee9d119ebc584be1837b3d959a25ace208ffac2fb703390a72d3027b64fdd1955b513c0403f09232efa1794a277e0be3f4f9f3a6fd23c6e52101e723cef5db7a2a18a107cd522379adb40c5ed36b26cdf53a1000d7d576f1157b42aac3d3ee011275')
with open(r"C:\Users\madha\Downloads\keys_and_messages_701dba5b1a84cb168547ec18227a7740\keys_and_messages\21.pem",'r') as f:
    key = RSA.import_key(f.read())
N = key.n
e = key.e

for i in range(1,51):
    with open(rf"C:\Users\madha\Downloads\keys_and_messages_701dba5b1a84cb168547ec18227a7740\keys_and_messages\{i}.pem",'r') as f:
        key = RSA.import_key(f.read())
    N_ = key.n
    if GCD(N,N_) != 1 and GCD(N,N_) != N:
        p = GCD(N,N_)
        break

q = N//p
phi =(p-1)*(q-1)
d = inverse(e,phi)

key = RSA.construct((N,e,d))
cipher = PKCS1_OAEP.new(key)

pt = cipher.decrypt(ct)
print(pt)
```
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/8c4ff831-2cf6-4d48-9ecb-68976b26c005)


<br><br><br>
***
<br><br><br>

# Bespoke Padding

### Description :
```
Been cooking up my own padding scheme, now my encrypted flag is different everytime!
Connect at socket.cryptohack.org 13386
```

### Solution :

connected and got the encrypted flag, modulus and padding by sending in `{"option" : "get_flag"}` \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/f5236ab3-6f6a-49ee-856f-c2e4a489b707)

after a while of going through the code, this is what I gathered : \
- same N would be used in 1 instance,
- but different messages are encrypted
- they are not entirely diffrent, the messages are in fact related
- random numbers, a and b are generated and the flag is padded into `msg = a*flag + b`

I googled around and found the answer here : https://en.wikipedia.org/wiki/Coppersmith%27s_attack \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/85bf760e-9ce0-4db6-955c-ad7f52323af1)

found further implementation on here : https://yanapermana.gitbooks.io/cry/content/rsa/quadratic-equation.html
so basically, we can define our ciphertexts as : \
`c1 = (a1*m + b1)^e % N`
`c2 = (a2*m + b2)^e % N`

according to Franklin Reiter's we can define two polynomials : \
`f1 = (a1*x + b1)^e - c1`
`f2 = (a2*x + b2)^e - c2`

the common root of the above polynomials would give us `m` i.e. the flag 
after a while cooked this : \
```python
from Crypto.Util.number import *
from sage.all import *

def gcd(a,b):
        while b:
                a,b = b,a%b
        return a.monic()

out1 = {"encrypted_flag": 3885215634454673279766480888853492499651623490374478948180596416085218089092569029466567034896892005410889025249050712519798152642204787058122956983643431219068368746933181181651030585173528928344871470672411943634494354070736141428555496111992072372383440669804298626796853781689133884950051674428591432793439534751232577629759809162942244214513026405735535155503064842168918764398997249317330476559172039897240648825951084445539694550650162211893249654842702695259489352173606995636785352474607725173519510532480772716038754424234044868282912164666162187336854641631962443413172854913721116170926463905953649272823, "modulus": 14983087128311710800966135453400665190223409829226021078795613784011283021399640094881063806271912143340369720882385162170480761857446022353075680339996023627043605254346232475144104409787247050892669523963505630781404170265407664219349160267286783579486719215781203634046165011545758538827826088657428048730301476683633433655215941278665873497299470738064519168715205256757569011640069834681033773323532411284127651888174591561311677438691167248661079032982335432430347783542365295990252983164398071842805208743507869866199075948235780669265797412374304940729309035915679965975623326501569196169681006177126919326261, "padding": [4408415636650717107941615252963422039081852071254039656837410141646419452712820675675442065763239482568073026520786758129784865113348834109071598625020449743247032231079177690755295469406312295144948793112323533657744070100580712269385845696928351320308117803145814501144217831264583682239376645774029271487737270591554544802431746263107324940659255879186267573819710429895489029076016750809832554765037431211226777104717015785183880578223092717049218356368670620243233911477817875908711382439865180462010247183195127697643595472032558140247000851101512753320963718581429927678708846183332888591266899046899889966144, 6417187790464685669406616073606787620240738529304597943190945953579037036714276455948088384893751954740534737578292156618165290773605079606125857855445986413551454298040391879044156432363874642088890096816559271636811631609533468648129450756485636963245613617547588516421008378495970062520309599851691836251601988957976980948270414371644608824245869057073175360207363248998297188201046659456471113967808133162630188720394635576643995736680795333071981179074216138694112503798953557223019313038952595866964766912527196543865153146291664886538698516001011829941142866186743801310475930871147042634237605841325756697017]}
out2 = {"encrypted_flag": 12223914883511361573082255216330362109300124658304759519155846535299718498955026791954482294019343344114234030332386070132625352510843524405992938066241341512595706333293840983168780198819773871016578433154978665487628831660692124310374717452040918921599392482496049927154681796422703192074593834586701828855544729261474417954847904451776821886047777765475525706394200950823175212614648022954573133799040732114098117262108117939471181058306820862442348734218241059465635164332619794219547451724338893320048820830558124789381698183366368917348988963921031432657031259096949805296532658489668080052917216492235167682123, "modulus": 14983087128311710800966135453400665190223409829226021078795613784011283021399640094881063806271912143340369720882385162170480761857446022353075680339996023627043605254346232475144104409787247050892669523963505630781404170265407664219349160267286783579486719215781203634046165011545758538827826088657428048730301476683633433655215941278665873497299470738064519168715205256757569011640069834681033773323532411284127651888174591561311677438691167248661079032982335432430347783542365295990252983164398071842805208743507869866199075948235780669265797412374304940729309035915679965975623326501569196169681006177126919326261, "padding": [12722227329720117089746115827516590118233308259578384588136074002377530415448780069710737715829858300308366528131149253696820093730897723247568777989115706078374045967202097619652028368539846111881209123536325260454164183363057695026678832340604714048531094868958806824947208415983769421860402415400660888999235795095620621223219956069651463037146482620315387698804730279860524303025334020098923044074699117592233639975179305104361704034596017769682541390389241126690829739299457912307232733054017101406819644375425582173825616240030631781162001489216326339678289581932967402654371838031754003389611134971027567413485, 6580261470618255696603783702998299704309439198467587984660203470050067031544470720750867294119566175534980182941717253898385144568890781126119515634282281631949760337032314746605214211536496704514816291418979858473312543207745881876218898363012104889036324857717830484942136530078547344198028128213833758639027465784090223547749575774404342687185020323418223046564184042558209636079557003251945422345384065234016744648120933562277417549919323875199892887946835616100654586598521421669990678741919391041021204621361609026669995009362655848756505759328789343543356006274623033156317163301958308618265618827568306082662]}
N = out1["modulus"]
e = 11

a1 = out1["padding"][0]
b1 = out1["padding"][1]

a2 = out2["padding"][0]
b2 = out2["padding"][1]

c1 = out1["encrypted_flag"]
c2 = out2["encrypted_flag"]

# extracted from https://yanapermana.gitbooks.io/cry/content/rsa/quadratic-equation.html
R.<x> = PolynomialRing(Zmod(N))
f1 = (a1*x + b1)**e - c1
f2 = (a2*x + b2)**e - c2
flag = -gcd(f1,f2).coefficients()[0]
print(long_to_bytes(flag))
```
and yes 
`crypto{linear_padding_isnt_padding}`


<br><br><br>
***
<br><br><br>

# Signatures Part 1

### Description :
```
My boss has so many emails he's set up a server to just sign everything automatically. He also stores encrypted messages to himself for easy access. I wonder what he's been saying.

Connect at socket.cryptohack.org 13374
```

### Solution :
Going through the code, I see that we can get, `N`, `e`, `ct` and "sign" our own msg \
if you look at the signing part : \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/fcf51f77-b573-4a51-9a8b-6e7669708ce7)

it returns pow(msg,d,n) \
now we know ct, and \
we know what pow(ct,d,n) gives... \
I did just that \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/5d8aff19-485f-40d0-a615-446aea66755b)

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/6e6a56cd-7002-450c-8ce0-58914b5ec0ee)

`crypto{d0n7_516n_ju57_4ny7h1n6}`

