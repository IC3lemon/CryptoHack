# Factoring

### Description : 
```
So far we've been using the product of small primes for the modulus, but small primes aren't much good for RSA as they can be factorised using modern methods.

What is a "small prime"? There was an RSA Factoring Challenge with cash prizes given to teams who could factorise RSA moduli. This gave insight to the public into how long various key sizes would remain safe. Computers get faster, algorithms get better, so in cryptography it's always prudent to err on the side of caution.

These days, using primes that are at least 1024 bits long is recommendedâ€”multiplying two such 1024 primes gives you a modulus that is 2048 bits large. RSA with a 2048-bit modulus is called RSA-2048.

Some say that to really remain future-proof you should use RSA-4096 or even RSA-8192. However, there is a tradeoff here; it takes longer to generate large prime numbers, plus modular exponentiations are predictably slower with a large modulus.

Factorise the 150-bit number 510143758735509025530880200653196460532653147 into its two constituent primes. Give the smaller one as your answer.
```

### Solution :

```python
from sympy import *

N = 510143758735509025530880200653196460532653147
primes = list(factorint(N).keys())

print("i think :", min(primes))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/212e4051-97a8-4bb2-8df4-7b7e7ea25c47)
<br><br><br>
***
<br><br><br>

# Inferius Prime

### Description :
```
Here is my super-strong RSA implementation, because it's 1600 bits strong it should be unbreakable... at least I think so!
```

```python
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD

e = 3

# n will be 8 * (100 + 100) = 1600 bits strong which is pretty good
while True:
    p = getPrime(100)
    q = getPrime(100)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    if d != -1 and GCD(e, phi) == 1:
        break

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag
```
```
n = 742449129124467073921545687640895127535705902454369756401331
e = 3
ct = 39207274348578481322317340648475596807303160111338236677373
```

### Solution :

my boi factorint failed me here, so I turned to another boi factordb

```python
from Crypto.Util.number import *
from factordb.factordb import FactorDB

n = 742449129124467073921545687640895127535705902454369756401331
e = 3
ct = 39207274348578481322317340648475596807303160111338236677373

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

p = primes[0]
q = primes[1]

phi = (p-1)*(q-1)
d = inverse(e,phi)

pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/2c6fe08a-fa8d-41b5-a294-2999711deda1)

<br><br><br>
***
<br><br><br>

# Monoprime

### Description :
```
Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?
```
```
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942
```

### Sollution :

got two approaches for this...
1. Something I learnt from cryptohack...
   p = n, q = 1 (duh)
   so phi = p-1 (phi cannot be zero, that won't make sense. So no multiplying q-1)
   we got phi, e, get d = e^-1 % phi, and solved with pow(ct,d,n)
```
from Crypto.Util.number import *

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

phi = n-1
d = inverse(e,phi)

pt = pow(ct,d,n)
print(long_to_bytes(pt))
```


2. Something I learnt in boilerctf... roots of unity
```
from Crypto.Util.number import *

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

def roots_of_unity(e, phi, n, rounds=500):
    phi_coprime = phi
    while GCD(phi_coprime, e) != 1:
        phi_coprime //=  GCD(phi_coprime, e)

    roots = set(pow(i, phi_coprime, n) for i in range(1, rounds))
    return roots, phi_coprime

roots,phi = roots_of_unity(e, n-1, n)
d = pow(e, -1,phi)
a = pow(ct,d,n)
for root in roots:
    flag = long_to_bytes((root*a) % n)
    if b'crypto' in flag:
        print(flag) 
```

either way ... 

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/b963abcd-e557-4c0b-be01-72047b13ef99)


<br><br><br>
***
<br><br><br>

# Square Eyes

### Description :
```
It was taking forever to get a 2048 bit prime, so I just generated one and used it twice.
```
```
n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896
```

### Solution :

now the first thing I thought was, n = p * p. \
So why not just do p =sqrt(n) \
and then phi = (p-1)*(p-1)

I tried that, but this is what I got at the end \
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/239ee607-4dab-4107-b0c9-cc9e5c5c6ad8)

the p i got from square rooting was alright, it was prime. 
and this was hinting at something related to this issue im having im pretty sure. 
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/63eb75cf-b3eb-46ab-a92b-5f3dde8e5ba7)


so I set out to search what would phi(n) be for n = p^2

and I found gold at https://www.whitman.edu/mathematics/higher_math_online/section03.08.html

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/527f956d-5104-45ff-a72c-0edf116f194d)

i have a similar situation. I want phi(p^2)
therefore. `phi(p^2) = p^2-p`

```python
from Crypto.Util.number import *
import sympy as sp

n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896

p = int(sp.sqrt(n))
#p = 23148667521998097720857168827790771337662483716348435477360567409355026169165934446949809664595523770853897203103759106983985113264049057416908191166720008503275951625738975666019029172377653170602440373579593292576530667773951407647222757756437867216095193174201323278896027294517792607881861855264600525772460745259440301156930943255240915685718552334192230264780355799179037816026330705422484000086542362084006958158550346395941862383925942033730030004606360308379776255436206440529441711859246811586652746028418496020145441513037535475380962562108920699929022900677901988508936509354385660735694568216631382653107
phi = (p**2) - p
d = inverse(e,phi)
pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/68c06e4b-38ba-47a8-a7e6-c0d1425b7eff)

<br><br><br>
***
<br><br><br>

# Manyprime

### Description :
```
Using one prime factor was definitely a bad idea so I'll try using over 30 instead.
```
```
n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464
```

### Solution :

not gonna lie, I was spoiled on this chall months ago during LACTF \
where my chad chad seniors told me about a chall on cryptohack similar to the one I was attempting then. \
Manyprime. I have the source code to solve this. but I did look up why and how it works \
and this is how i thiink it works 
![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/4f3bb96c-544c-4dd6-a008-4145c95d4ce6)

basically n = p * q * r * s * t * ... \
where p,q,r,s,t are all primes, and also relatively prime to each other. \
thus phi(n) = phi(p) * phi(q) * phi(r) * phi(s) * ... \
=> phi(n) = (p-1) * (q-1) * (r-1) * ...

```python
from Crypto.Util.number import *
import sympy as sp
from factordb.factordb import FactorDB

n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464

f = FactorDB(n)
f.connect()
primes = f.get_factor_list()

phi = 1
for i in range(len(primes)):
    phi *= primes[i] - 1

d = inverse(e,phi)
pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

![image](https://github.com/IC3lemon/CryptoHack/assets/150153966/16027cee-ea50-439c-b5dd-69788835c9ea)


<br><br><br>
***
<br><br><br>

# 
